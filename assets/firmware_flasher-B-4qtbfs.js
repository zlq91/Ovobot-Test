import{F as E,G as m,C as pe,L as y,I as l,V as u,W as Ee,M as w,X as B,Y as we,Z as z,T as g,_ as Re,$ as t,z as Ue,g as H,N as me,a0 as Y,P as N,H as Z,a1 as _e,a2 as Ge,s as U,E as Ve,D as O}from"./DarkTheme-DoxdKMtD.js";import{B as ze,g as Ye,s as Ke}from"./BuildApi-Cg_hicDr.js";import{u as qe}from"./common-BMtqj22a.js";import{S as We}from"./Sponsor-B21RzQzY.js";import{g as Xe}from"./generate_filename-BIkfQQdx.js";import{i as le}from"./connection-Jf28wLbE.js";import"./main-CAeNTcHC.js";const je=134227968,be=16384;function Ce(r,e){let o=0;for(;o<r.data.length&&e>=r.data[o].address+r.data[o].bytes;o++);const a={lineIndex:o};return r.data[o]&&e>=r.data[o].address&&(a.byteIndex=e-r.data[o].address),a}function ve(r,e){let o=0;for(let a=0;a<4;a++)o+=r.data[e.lineIndex].data[e.byteIndex++]<<8*a,e.byteIndex>=r.data[e.lineIndex].bytes&&(e.lineIndex++,e.byteIndex=0);return o}function Ze(r){const e={},o=Ce(r,je);if(o.byteIndex!==void 0)return e.startAddress=ve(r,o),e.endAddress=ve(r,o),e}function Je(r,e,o){let a=o;const n=Ce(r,a);if(n.byteIndex!==void 0)throw new Error("Configuration area in firmware not free.");let d=0;for(;d<e.length;){const f=e.length-d,c={address:a,bytes:be>f?f:be,data:[]};if(r.data[n.lineIndex]&&c.address+c.bytes>r.data[n.lineIndex].address)throw new Error("Aborting data generation, free area too small.");for(let _=0;_<c.bytes;_++)c.data.push(e.charCodeAt(d++));a=a+c.bytes,r.data.splice(n.lineIndex++,0,c)}r.bytes_total+=e.length}const Se="Custom defaults inserted in";class Qe{insertConfig(e,o){console.time(Se);const a=`# Ovobot
${o}\0`,n=Ze(e);if(!n||n.endAddress-n.startAddress===0)return!1;if(a.length>=n.endAddress-n.startAddress)throw new Error(`Custom defaults area too small (${n.endAddress-n.startAddress} bytes), ${a.length+1} bytes needed.`);return Je(e,a,n.startAddress),console.timeEnd(Se),!0}}const Fe="HEX_PARSER - File parsed in";async function et(r){console.time(Fe),r=r.split(`
`),r[r.length-1]==""&&r.pop();let e=!0;const o={data:[],end_of_file:!1,bytes_total:0,start_linear_address:0};let a=0,n=0;for(let d=0;d<r.length&&e;d++){const f=parseInt(r[d].substr(1,2),16),c=parseInt(r[d].substr(3,4),16),_=parseInt(r[d].substr(7,2),16),x=r[d].substr(9,f*2),F=parseInt(r[d].substr(9+f*2,2),16);switch(_){case 0:{(c!==n||n===0)&&o.data.push({address:a+c,bytes:0,data:[]}),n=c+f;let k=f+parseInt(r[d].substr(3,2),16)+parseInt(r[d].substr(5,2),16)+_;for(let I=0;I<f*2;I+=2){const L=parseInt(x.substr(I,2),16),P=o.data.length-1;o.data[P].data.push(L),o.data[P].bytes++,k+=L,o.bytes_total++}k=~k+1&255,k!=F&&(e=!1);break}case 1:o.end_of_file=!0;break;case 2:parseInt(x,16)!=0&&console.log("extended segment address record found - NOT IMPLEMENTED !!!");break;case 3:parseInt(x,16)!=0&&console.log("start segment address record found - NOT IMPLEMENTED !!!");break;case 4:a=(parseInt(x.substr(0,2),16)<<24|parseInt(x.substr(2,2),16)<<16)>>>0;break;case 5:o.start_linear_address=parseInt(x,16);break}}return console.timeEnd(Fe),o.end_of_file&&e?o:null}function ne(r){we(r.detail)}function tt(){u.disconnect(r=>{console.log("Disconnected",r),w.clearListeners(),this.onTimeoutCallback()}),w.disconnect_cleanup()}class st{constructor(){this.baud=void 0,this.port=void 0,this.onConnectCallback=void 0,this.onTimeoutCallback=void 0,this.onDisconnectCallback=void 0}handleConnect(e){if(e){E.resetState(),m.timeout_add("msp_connector",function(){pe.connectionValid||(y(l.getMessage("noConfigurationReceived")),tt())},1e4),u.removeEventListener("receive",ne),u.addEventListener("receive",ne);const o=new Ee;w.listen(o.process_data.bind(o)),w.send_message(B.CMD_VERSION,!1,!1,()=>{pe.connectionValid=!0,m.timeout_remove("msp_connector"),console.log("Connected"),this.onConnectCallback()})}else y(l.getMessage("serialPortOpenFail")),this.onFailureCallback()}handleDisconnect(e){console.log("Disconnected",e),u.removeEventListener("receive",ne),u.removeEventListener("connect",o=>this.handleConnect(o.detail)),u.removeEventListener("disconnect",o=>this.handleDisconnect(o)),w.clearListeners(),w.disconnect_cleanup()}connect(e,o,a,n,d){this.port=e,this.baud=o,this.onConnectCallback=a,this.onTimeoutCallback=n,this.onFailureCallback=d,u.removeEventListener("connect",f=>this.handleConnect(f.detail)),u.addEventListener("connect",f=>this.handleConnect(f.detail),{once:!0}),u.removeEventListener("disconnect",f=>this.handleDisconnect(f)),u.addEventListener("disconnect",f=>this.handleDisconnect(f),{once:!0}),u.connect(this.port,{baudRate:this.baud})}disconnect(e){this.onDisconnectCallback=e,u.disconnect(o=>{w.clearListeners(),console.log("Disconnected",o),this.onDisconnectCallback(o)}),w.disconnect_cleanup()}}function xe(r){we(r.detail.buffer)}function ot(){m.connect_lock=!1,console.log(`${Ae.logHead} Looking for capabilities via MSP failed`),g.firmware_flasher.flashingMessage(l.getMessage("stm32RebootingToBootloaderFailed"),g.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID)}function at(){m.connect_lock=!1,g.firmware_flasher.refresh()}class Ae{constructor(){this.logHead="[STM32]",this.baud=null,this.options={},this.callback=null,this.hex=null,this.verify_hex=[],this.receive_buffer=[],this.bytesToRead=0,this.read_callback=null,this.upload_time_start=0,this.upload_process_alive=!1,this.mspConnector=new st,this.status={ACK:121,NACK:31},this.command={get:0,get_ver_r_protect_s:1,get_ID:2,read_memory:17,go:33,write_memory:49,erase:67,extended_erase:68,write_protect:99,write_unprotect:115,readout_protect:130,readout_unprotect:146},this.available_flash_size=0,this.page_size=0,this.useExtendedErase=!1,this.rebootMode=0,this.handleMSPConnect=this.handleMSPConnect.bind(this)}handleConnect(e){console.log(`${this.logHead} Connected to serial port`,e.detail,e),e?(m.connect_lock=!0,this.initialize()):y(l.getMessage("serialPortOpenFail"))}handleDisconnect(e){console.log(`${this.logHead} Waiting for DFU connection`),u.removeEventListener("connect",o=>this.handleConnect(o.detail)),u.removeEventListener("disconnect",o=>this.handleDisconnect(o.detail)),e&&this.rebootMode?setTimeout(()=>{this.rebootMode&&(console.log(`${this.logHead} STM32 Requesting permission for device`),z.requestPermission().then(o=>{o!=null?console.log(`${this.logHead} DFU request permission granted`,o):(console.error(`${this.logHead} DFU request permission denied`),this.rebootMode=0,m.connect_lock=!1)}).catch(o=>{console.error(`${this.logHead} DFU request permission failed`,o),this.rebootMode=0,m.connect_lock=!1}))},3e3):m.connect_lock=!1}prepareSerialPort(){u.removeEventListener("connect",e=>this.handleConnect(e.detail)),u.addEventListener("connect",e=>this.handleConnect(e.detail),{once:!0}),u.removeEventListener("disconnect",e=>this.handleDisconnect(e.detail)),u.addEventListener("disconnect",e=>this.handleDisconnect(e.detail),{once:!0})}reboot(){const e=[];e.push8(this.rebootMode),setTimeout(()=>{w.promise(B.MSP_SET_REBOOT,e).then(()=>{this.mspConnector.disconnect(o=>{console.log(`${this.logHead} Disconnecting from MSP`,o)})}),console.log(`${this.logHead} Reboot request received by device`)},100)}onAbort(){m.connect_lock=!1,this.rebootMode=0,console.log(`${this.logHead} User cancelled because selected target does not match verified board`),this.reboot(),g.firmware_flasher.refresh()}lookingForCapabilitiesViaMSP(){console.log(`${this.logHead} Looking for capabilities via MSP`),w.promise(B.MSP_BOARD_INFO).then(()=>{Re(E.CONFIG.targetCapabilities,E.TARGET_CAPABILITIES_FLAGS.HAS_FLASH_BOOTLOADER)?(y(l.getMessage("deviceRebooting_flashBootloader")),console.log(`${this.logHead} flash bootloader detected`),this.rebootMode=4):(y(l.getMessage("deviceRebooting_romBootloader")),console.log(`${this.logHead} no flash bootloader detected`),this.rebootMode=1);const e=g.firmware_flasher.selectedBoard!=="0"?g.firmware_flasher.selectedBoard:"NONE",o=E.CONFIG.boardName?E.CONFIG.boardName:"UNKNOWN";try{e!==o&&!g.firmware_flasher.localFirmwareLoaded?g.firmware_flasher.showDialogVerifyBoard(e,o,this.reboot.bind(this),this.onAbort.bind(this)):this.reboot()}catch(a){console.error(a),this.reboot()}})}handleMSPConnect(){y(l.getMessage("apiVersionReceived",[E.CONFIG.apiVersion])),this.lookingForCapabilitiesViaMSP()}connect(e,o,a,n,d){this.hex=a,this.port=e,this.baud=o,this.callback=d,this.serialOptions=n,this.mspOptions={no_reboot:!1,reboot_baud:!1,erase_chip:!1},n.no_reboot?this.mspOptions.no_reboot=!0:this.mspOptions.reboot_baud=n.reboot_baud,n.erase_chip&&(this.mspOptions.erase_chip=!0),this.options.no_reboot?(this.prepareSerialPort(),u.connect(e,{baudRate:this.baud,parityBit:"even",stopBits:"one"})):(this.rebootMode=0,m.connect_lock=!0,g.firmware_flasher.flashingMessage(l.getMessage("stm32RebootingToBootloader"),g.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL),u.addEventListener("disconnect",f=>this.handleDisconnect(f.detail),{once:!0}),this.mspConnector.connect(this.port,this.mspOptions.reboot_baud,this.handleMSPConnect,ot,at))}initialize(){this.receive_buffer=[],this.verify_hex=[],this.upload_time_start=new Date().getTime(),this.upload_process_alive=!1,g.firmware_flasher.flashingMessage(null,g.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL).flashProgress(0),t('select[name="release"]').prop("disabled",!0),u.removeEventListener("receive",xe),u.addEventListener("receive",xe),m.interval_add("STM32_timeout",()=>{this.upload_process_alive?this.upload_process_alive=!1:(console.log(`${this.logHead} STM32 - timed out, programming failed ...`),g.firmware_flasher.flashingMessage(l.getMessage("stm32TimedOut"),g.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),m.interval_remove("STM32_timeout"),this.upload_procedure(99))},2e3),console.log(`${this.logHead} STM32 - Initialization done, starting upload procedure`),this.upload_procedure(1)}read(e){const o=new Uint8Array(e.data);for(const a of o)this.receive_buffer.push(a);if(this.receive_buffer.length>=this.bytesToRead&&this.bytesToRead!=0){const a=this.receive_buffer.slice(0,this.bytesToRead);this.receive_buffer.splice(0,this.bytesToRead),this.bytesToRead=0,this.read_callback(a)}}retrieve(e,o){if(this.receive_buffer.length>=e){const a=this.receive_buffer.slice(0,e);this.receive_buffer.splice(0,e),o(a)}else this.bytesToRead=e,this.read_callback=o}send(e,o,a){this.upload_process_alive=!0;const n=new ArrayBuffer(e.length);new Uint8Array(n).set(e),this.bytesToRead=o,this.read_callback=a,this.receive_buffer=[],u.send(n)}verify_response(e,o){if(e!==o[0]){const a=`STM32 Communication failed, wrong response, expected: ${e} (0x${e.toString(16)}) received: ${o[0]} (0x${o[0].toString(16)})`;return console.error(a),g.firmware_flasher.flashingMessage(l.getMessage("stm32WrongResponse",[e,e.toString(16),o[0],o[0].toString(16)]),g.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),this.upload_procedure(99),!1}return!0}verify_chip_signature(e){switch(e){case 1042:console.log(`${this.logHead} Chip recognized as F1 Low-density`);break;case 1040:console.log(`${this.logHead} Chip recognized as F1 Medium-density`),this.available_flash_size=131072,this.page_size=1024;break;case 1044:this.available_flash_size=262144,this.page_size=2048,console.log(`${this.logHead} Chip recognized as F1 High-density`);break;case 1048:console.log(`${this.logHead} Chip recognized as F1 Connectivity line`);break;case 1056:console.log(`${this.logHead} Chip recognized as F1 Medium-density value line`);break;case 1064:console.log(`${this.logHead} Chip recognized as F1 High-density value line`);break;case 1072:console.log(`${this.logHead} Chip recognized as F1 XL-density value line`);break;case 1046:console.log(`${this.logHead} Chip recognized as L1 Medium-density ultralow power`);break;case 1078:console.log(`${this.logHead} Chip recognized as L1 High-density ultralow power`);break;case 1063:console.log(`${this.logHead} Chip recognized as L1 Medium-density plus ultralow power`);break;case 1041:console.log(`${this.logHead} Chip recognized as F2 STM32F2xxxx`);break;case 1088:console.log(`${this.logHead} Chip recognized as F0 STM32F051xx`);break;case 1092:console.log(`${this.logHead} Chip recognized as F0 STM32F050xx`);break;case 1043:console.log(`${this.logHead} Chip recognized as F4 STM32F40xxx/41xxx`);break;case 1049:console.log(`${this.logHead} Chip recognized as F4 STM32F427xx/437xx, STM32F429xx/439xx`);break;case 1074:console.log(`${this.logHead} Chip recognized as F3 STM32F37xxx, STM32F38xxx`);break;case 1058:console.log(`${this.logHead} Chip recognized as F3 STM32F30xxx, STM32F31xxx`),this.available_flash_size=262144,this.page_size=2048;break;default:console.log(`${this.logHead} Chip NOT recognized: ${e}`);break}return this.available_flash_size>0?this.hex.bytes_total<this.available_flash_size?!0:(console.log(`${this.logHead} Supplied hex is bigger then flash available on the chip, HEX: ${this.hex.bytes_total} bytes, limit = ${this.available_flash_size} bytes`),!1):(console.log(`${this.logHead} Chip NOT recognized: ${e}`),!1)}verify_flash(e,o){for(let a=0;a<e.length;a++)if(e[a]!==o[a])return console.log(`${this.logHead} Verification failed on byte: ${a} expected: 0x${e[a].toString(16)} received: 0x${o[a].toString(16)}`),!1;return console.log(`${this.logHead} Verification successful, matching: ${e.length} bytes`),!0}upload_procedure(e){switch(e){case 1:{g.firmware_flasher.flashingMessage(l.getMessage("stm32ContactingBootloader"),g.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL);let o=0;m.interval_add("stm32_initialize_mcu",()=>{this.send([127],1,a=>{a[0]===127||a[0]===this.status.ACK||a[0]===this.status.NACK?(m.interval_remove("stm32_initialize_mcu"),console.log(`${this.logHead} Serial interface initialized on the MCU side`),this.upload_procedure(2)):(g.firmware_flasher.flashingMessage(l.getMessage("stm32ContactingBootloaderFailed"),g.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),m.interval_remove("stm32_initialize_mcu"),this.upload_procedure(99))}),o++>3&&(console.log(`${this.logHead} No response from bootloader, disconnecting`),g.firmware_flasher.flashingMessage(l.getMessage("stm32ResponseBootloaderFailed"),g.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),m.interval_remove("stm32_initialize_mcu"),m.interval_remove("STM32_timeout"),this.upload_procedure(99))},250,!0);break}case 2:{this.send([this.command.get,255],2,o=>{this.verify_response(this.status.ACK,o)&&this.retrieve(o[1]+1+1,a=>{console.log(`${this.logHead} Bootloader version: ${(parseInt(a[0].toString(16))/10).toFixed(1)}`),this.useExtendedErase=a[7]===this.command.extended_erase,this.upload_procedure(3)})});break}case 3:this.send([this.command.get_ID,253],2,o=>{this.verify_response(this.status.ACK,o)&&this.retrieve(o[1]+1+1,a=>{const n=a[0]<<8|a[1];console.log(`${this.logHead} Signature: 0x${n.toString(16)}`),this.verify_chip_signature(n)?this.upload_procedure(4):this.upload_procedure(99)})});break;case 4:{if(this.useExtendedErase){this.options.erase_chip?(console.log(`${this.logHead} Executing global chip erase (via extended erase)`),g.firmware_flasher.flashingMessage(l.getMessage("stm32GlobalEraseExtended"),g.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL),this.send([this.command.extended_erase,187],1,o=>{this.verify_response(this.status.ACK,o)&&this.send([255,255,0],1,a=>{this.verify_response(this.status.ACK,a)&&(console.log(`${this.logHead} Executing global chip extended erase: done`),this.upload_procedure(5))})})):(console.log(`${this.logHead} Executing local erase (via extended erase)`),g.firmware_flasher.flashingMessage(l.getMessage("stm32LocalEraseExtended"),g.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL),this.send([this.command.extended_erase,187],1,o=>{if(this.verify_response(this.status.ACK,o)){const a=this.hex.data[this.hex.data.length-1].address+this.hex.data[this.hex.data.length-1].bytes-134217728,n=Math.ceil(a/this.page_size),d=[];let f=0,c;c=n-1>>8,d.push(c),f^=c,c=n-1&255,d.push(c),f^=c;for(let _=0;_<n;_++)c=_>>8,d.push(c),f^=c,c=_&255,d.push(c),f^=c;d.push(f),console.log(`${this.logHead} Erasing. pages: 0x00 - 0x${n.toString(16)}, checksum: 0x${f.toString(16)}`),this.send(d,1,_=>{this.verify_response(this.status.ACK,_)&&(console.log(`${this.logHead} Erasing: done`),this.upload_procedure(5))})}}));break}this.options.erase_chip?(console.log(`${this.logHead} Executing global chip erase`),g.firmware_flasher.flashingMessage(l.getMessage("stm32GlobalErase"),g.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL),this.send([this.command.erase,188],1,o=>{this.verify_response(this.status.ACK,o)&&this.send([255,0],1,a=>{this.verify_response(this.status.ACK,a)&&(console.log(`${this.logHead} Erasing: done`),this.upload_procedure(5))})})):(console.log(`${this.logHead} Executing local erase`),g.firmware_flasher.flashingMessage(l.getMessage("stm32LocalErase"),g.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL),this.send([this.command.erase,188],1,o=>{if(this.verify_response(this.status.ACK,o)){const a=this.hex.data[this.hex.data.length-1].address+this.hex.data[this.hex.data.length-1].bytes-134217728,n=Math.ceil(a/this.page_size),d=[];let f=n-1;d.push(n-1);for(let c=0;c<n;c++)d.push(c),f^=c;d.push(f),this.send(d,1,c=>{this.verify_response(this.status.ACK,c)&&(console.log(`${this.logHead} Erasing: done`),this.upload_procedure(5))})}}));break}case 5:{console.log(`${this.logHead} Writing data ...`),g.firmware_flasher.flashingMessage(l.getMessage("stm32Flashing"),g.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL);let o=this.hex.data.length-1,a=0,n=this.hex.data[a].address,d=0,f=0;const c=()=>{if(d<this.hex.data[a].bytes){const _=d+256<=this.hex.data[a].bytes?256:this.hex.data[a].bytes-d;this.send([this.command.write_memory,206],1,x=>{if(this.verify_response(this.status.ACK,x)){const F=[n>>24,n>>16,n>>8,n],k=F[0]^F[1]^F[2]^F[3];this.send([F[0],F[1],F[2],F[3],k],1,I=>{if(this.verify_response(this.status.ACK,I)){const L=Array.from(_+2);L[0]=_-1;let P=L[0];for(let D=0;D<_;D++)L[D+1]=this.hex.data[a].data[d],P^=this.hex.data[a].data[d],d++;L[L.length-1]=P,n+=_,f+=_,this.send(L,1,D=>{this.verify_response(this.status.ACK,D)&&c()}),g.firmware_flasher.flashProgress(Math.round(f/(this.hex.bytes_total*2)*100))}})}})}else a<o?(a++,n=this.hex.data[a].address,d=0,c()):(console.log(`${this.logHead} Writing: done`),this.upload_procedure(6))};c();break}case 6:{console.log(`${this.logHead} Verifying data ...`),g.firmware_flasher.flashingMessage(l.getMessage("stm32Verifying"),g.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL);const o=this.hex.data.length-1;let a=0,n=this.hex.data[a].address,d=0,f=0;for(let _=0;_<=o;_++)this.verify_hex.push([]);const c=()=>{if(d<this.hex.data[a].bytes){const _=d+256<=this.hex.data[a].bytes?256:this.hex.data[a].bytes-d;this.send([this.command.read_memory,238],1,x=>{if(this.verify_response(this.status.ACK,x)){const F=[n>>24,n>>16,n>>8,n],k=F[0]^F[1]^F[2]^F[3];this.send([F[0],F[1],F[2],F[3],k],1,I=>{if(this.verify_response(this.status.ACK,I)){const L=_-1;this.send([L,~L&255],1,P=>{this.verify_response(this.status.ACK,P)&&this.retrieve(_,D=>{for(const V of D)this.verify_hex[a].push(V);n+=_,d+=_,f+=_,c()})}),g.firmware_flasher.flashProgress(Math.round((this.hex.bytes_total+f)/(this.hex.bytes_total*2)*100))}})}})}else if(a<o)a++,n=this.hex.data[a].address,d=0,c();else{let _=!0;for(let x=0;x<=o&&(_=this.verify_flash(this.hex.data[x].data,this.verify_hex[x]),!!_);x++);_?(console.log(`${this.logHead} Programming: SUCCESSFUL`),g.firmware_flasher.flashingMessage(l.getMessage("stm32ProgrammingSuccessful"),g.firmware_flasher.FLASH_MESSAGE_TYPES.VALID),H("showNotifications").showNotifications&&me.showNotification("Ovobot Configurator",{body:l.getMessage("programmingSuccessfulNotification"),icon:"/images/pwa/favicon.ico"}),this.upload_procedure(7)):(console.log(`${this.logHead} Programming: FAILED`),g.firmware_flasher.flashingMessage(l.getMessage("stm32ProgrammingFailed"),g.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),H("showNotifications").showNotifications&&me.showNotification("Ovobot Configurator",{body:l.getMessage("programmingFailedNotification"),icon:"/images/pwa/favicon.ico"}),this.upload_procedure(99))}};c();break}case 7:{console.log(`${this.logHead} Sending GO command: 0x8000000`),this.send([this.command.go,222],1,o=>{if(this.verify_response(this.status.ACK,o)){const n=[8,2048,524288,134217728],d=n[0]^n[1]^n[2]^n[3];this.send([n[0],n[1],n[2],n[3],d],1,f=>{this.verify_response(this.status.ACK,f)&&this.upload_procedure(99)})}});break}case 99:{m.interval_remove("STM32_timeout"),u.connectionId?u.disconnect(this.cleanup):this.cleanup();break}}}cleanup(){Ue.reset(),m.connect_lock=!1,t('select[name="release"]').prop("disabled",!1);const e=new Date().getTime()-this.upload_time_start;console.log(`${this.logHead} Script finished after: ${e/1e3} seconds`),this.callback&&this.callback()}}const te=new Ae;class it{constructor(){this.outputHistory="",this.callback=null,this.boundReadSerialAdapter=null,this.boundHandleConnect=null,this.boundHandleDisconnect=null}handleConnect(e){console.log("Connected to serial port:",e),e?(this.cleanupListeners(),this.outputHistory="",this.boundReadSerialAdapter=this.readSerialAdapter.bind(this),u.addEventListener("receive",this.boundReadSerialAdapter),this.run()):y(l.getMessage("serialPortOpenFail"))}handleDisconnect(e){y(l.getMessage(e.detail?"serialPortClosedOk":"serialPortClosedFail")),this.cleanupListeners()}cleanupListeners(){this.boundReadSerialAdapter&&(u.removeEventListener("receive",this.boundReadSerialAdapter),this.boundReadSerialAdapter=null),this.boundHandleConnect&&(u.removeEventListener("connect",this.boundHandleConnect),this.boundHandleConnect=null),this.boundHandleDisconnect&&(u.removeEventListener("disconnect",this.boundHandleDisconnect),this.boundHandleDisconnect=null)}readSerialAdapter(e){const o=new Uint8Array(e.detail.data);for(const a of o){const n=String.fromCharCode(a);this.outputHistory+=n}}onClose(){this.boundHandleDisconnect=this.handleDisconnect.bind(this),u.addEventListener("disconnect",this.boundHandleDisconnect,{once:!0}),u.disconnect()}async save(e){console.log("Saving backup");const o="cli_backup",a="txt",n=Xe(o,a);let d=!1;try{const f=await Y.pickSaveFile(n,l.getMessage("fileSystemPickerFiles",{typeof:a.toUpperCase()}),`.${a}`);f&&(console.log("Saving config to:",f.name),await Y.writeFile(f,e),d=!0)}catch(f){console.error("Error saving config:",f)}finally{this.callback&&this.callback(d)}}async run(){console.log("Running backup"),await this.activateCliMode(),this.waitForCommandCompletion("diff all")}waitForCommandCompletion(e){this.outputHistory="",this.sendCommand(e),console.log(`AutoBackup: Command sent: "${e}"`);const o=100,a=3e4;let n=0;const d=setInterval(()=>{if(n+=o,n%1e3===0&&(console.log(`AutoBackup: Waiting for ${n/1e3}s, buffer length: ${this.outputHistory.length} chars`),this.outputHistory.length>0)){const c=this.outputHistory.slice(-30).replace(/\r/g,"\\r").replace(/\n/g,"\\n");console.log(`AutoBackup: Last chars: "${c}"`)}if(this.outputHistory.endsWith("# ")||this.outputHistory.endsWith("#\r")||this.outputHistory.endsWith(`#
`)||this.outputHistory.endsWith(`#\r
`)||this.outputHistory.match(/\r?\n# ?$/)){clearInterval(d),console.log("AutoBackup: Prompt detected, processing output");let c=this.outputHistory.split(/\r?\n/);console.log(`AutoBackup: Received ${c.length} lines of output`),c[0].includes(e)&&(c=c.slice(1),console.log("AutoBackup: Removed command line from output")),c.length>0&&(c[c.length-1].trim()==="#"||c[c.length-1].trim()==="")&&(c=c.slice(0,-1),console.log("AutoBackup: Removed prompt line from output"));const _=c.join(`
`);console.log(`AutoBackup: Final data length: ${_.length} chars`),this.sendCommand("exit",this.onClose.bind(this)),this.save(_)}else if(n>=a){clearInterval(d),console.error(`AutoBackup: Timeout waiting for command completion after ${a/1e3}s`),console.log(`AutoBackup: Saving partial data, buffer length: ${this.outputHistory.length}`);const c=this.outputHistory.split(/\r?\n/),x=(c[0].includes(e)?c.slice(1):c).join(`
`);this.sendCommand("exit",this.onClose.bind(this)),this.save(x)}},o)}async activateCliMode(){return new Promise(e=>{const o=new ArrayBuffer(1),a=new Uint8Array(o);a[0]=35,u.send(o),setTimeout(()=>{this.outputHistory="",e()},1e3)})}async sendSerial(e,o){const a=new ArrayBuffer(e.length),n=new Uint8Array(a);for(let d=0;d<e.length;d++)n[d]=e.charCodeAt(d);u.send(a,o)}async sendCommand(e,o){this.sendSerial(`${e}
`,o)}execute(e){this.outputHistory="",this.callback=e,this.cleanupListeners();const o=N.portPicker.selectedPort,a=N.portPicker.selectedBauds;o.startsWith("serial")?(this.boundHandleConnect=this.handleConnect.bind(this),u.addEventListener("connect",this.boundHandleConnect,{once:!0}),u.connect(o,{baudRate:a})):y(l.getMessage("firmwareFlasherNoPortSelected"))}}const nt=new it;let j=null;class lt{constructor(){this.board=E.CONFIG.boardName,this.targetAvailable=!1,this.boundHandleConnect=this.handleConnect.bind(this),this.boundHandleDisconnect=this.handleDisconnect.bind(this),this.boundHandleSerialReceive=this.handleSerialReceive.bind(this)}handleSerialReceive(e){w.read(e.detail)}verifyBoard(){const e=N.portPicker.selectedPort;if(!(g.firmware_flasher.targets?Object.keys(g.firmware_flasher.targets).length>0:!1)){console.log("Releases not loaded yet"),y(l.getMessage("firmwareFlasherNoTargetsLoaded"));return}if(u.connected||u.connectionId){console.warn("Attempting to connect while there still is a connection",u.connected,u.connectionId,u.openCanceled),u.disconnect();return}y(l.getMessage("firmwareFlasherDetectBoardQuery")),e.startsWith("serial")?(u.addEventListener("connect",this.boundHandleConnect,{once:!0}),u.addEventListener("disconnect",this.boundHandleDisconnect,{once:!0}),u.selectProtocol("serial"),u.connect(e,{baudRate:115200})):y(l.getMessage("serialPortOpenFail"))}handleConnect(e){this.onConnect(e.detail)}handleDisconnect(e){this.onClosed(e.detail)}onClosed(e){y(l.getMessage(e?"serialPortClosedOk":"serialPortClosedFail")),this.targetAvailable||y(l.getMessage("firmwareFlasherBoardVerificationFail"))}onFinishClose(){const e=E.CONFIG.boardName;if(e){const o=$('select[name="board"]'),a=$('select[name="board"] option'),n=o.val();a.each((d,f)=>{$(f).text()===e&&(this.targetAvailable=!0)}),e!==n&&o.val(e).trigger("change"),y(l.getMessage(this.targetAvailable?"firmwareFlasherBoardVerificationSuccess":"firmwareFlasherBoardVerficationTargetNotAvailable",{boardName:e}))}u.removeEventListener("receive",this.boundHandleSerialReceive),u.removeEventListener("connect",this.boundHandleConnect),u.removeEventListener("disconnect",this.boundHandleDisconnect),w.clearListeners(),w.disconnect_cleanup(),u.disconnect()}async getBoardInfo(){await w.promise(B.MSP_BOARD_INFO),Z.gte(E.CONFIG.apiVersion,_e)&&(g.firmware_flasher.cloudBuildOptions=E.CONFIG.buildOptions),this.onFinishClose()}async getCloudBuildOptions(e){g.firmware_flasher.cloudBuildOptions=e.Request.Options,await this.getBoardInfo()}async getBuildInfo(){if(Z.gte(E.CONFIG.apiVersion,Ge)&&E.CONFIG.flightControllerIdentifier==="BTFL"){await w.promise(B.MSP2_GET_TEXT,j.crunch(B.MSP2_GET_TEXT,B.BUILD_KEY)),await w.promise(B.MSP2_GET_TEXT,j.crunch(B.MSP2_GET_TEXT,B.CRAFT_NAME)),await w.promise(B.CMD_BUILD_INFO),g.firmware_flasher.cloudBuildKey=E.CONFIG.buildKey;const e=new Date("3/21/2024"),o=new Date(E.CONFIG.buildInfo);if(g.firmware_flasher.validateBuildKey()&&(Z.lt(E.CONFIG.apiVersion,_e)||o<e))return g.firmware_flasher.buildApi.requestBuildOptions(g.firmware_flasher.cloudBuildKey,this.getCloudBuildOptions.bind(this),this.getBoardInfo.bind(this))}await this.getBoardInfo()}async requestBoardInformation(){await w.promise(B.CMD_VERSION),y(l.getMessage("apiVersionReceived",E.CONFIG.apiVersion)),E.CONFIG.apiVersion.includes("null")||Z.lt(E.CONFIG.apiVersion,"1.39.0")?this.onFinishClose():(await w.promise(B.MSP_FC_VARIANT),await this.getBuildInfo())}onConnect(e){e?(u.removeEventListener("receive",this.boundHandleSerialReceive),u.addEventListener("receive",this.boundHandleSerialReceive),j=new Ee,w.listen(j.process_data.bind(j)),this.requestBoardInformation()):y(l.getMessage("serialPortOpenFail"))}}const rt=new lt,M={targets:null,buildApi:new ze,sponsor:new We,localFirmwareLoaded:!1,selectedBoard:void 0,cloudBuildKey:null,cloudBuildOptions:null,isFlashing:!1,intel_hex:void 0,parsed_hex:void 0,isConfigLocal:!1,filename:null,configFilename:null,config:{},developmentFirmwareLoaded:!1,cancelBuild:!1};M.initialize=function(r){const e=this;m.active_tab!=="firmware_flasher"&&(m.active_tab="firmware_flasher"),e.selectedBoard=void 0,e.cloudBuildKey=null,e.cloudBuildOptions=null,e.localFirmwareLoaded=!1,e.isConfigLocal=!1,e.intel_hex=void 0,e.parsed_hex=void 0,e.logHead="[FIRMWARE_FLASHER]";function o(){function a(s,i){et(s).then(h=>{i(h)})}function n(s){var i,h;e.filename=s,e.localFirmwareLoaded?e.flashingMessage(l.getMessage("firmwareFlasherFirmwareLocalLoaded",{filename:s,bytes:e.parsed_hex.bytes_total}),e.FLASH_MESSAGE_TYPES.NEUTRAL):e.flashingMessage(`<a class="save_firmware" href="#" title="Save Firmware">${l.getMessage("firmwareFlasherFirmwareOnlineLoaded",{filename:s,bytes:e.parsed_hex.bytes_total})}</a>`,e.FLASH_MESSAGE_TYPES.NEUTRAL),e.enableFlashButton(!0),O.sendEvent(O.EVENT_CATEGORIES.FLASHING,"FirmwareLoaded",{firmwareSize:e.parsed_hex.bytes_total,firmwareName:s,firmwareSource:e.localFirmwareLoaded?"file":"http",selectedTarget:(i=e.targetDetail)==null?void 0:i.target,selectedRelease:(h=e.targetDetail)==null?void 0:h.release})}function d(s){s.manufacturer?(t("div.release_info #manufacturer").text(s.manufacturer),t("div.release_info #manufacturerInfo").show()):t("div.release_info #manufacturerInfo").hide(),t("div.release_info .target").text(s.target),t("div.release_info .name").text(s.release).prop("href",s.releaseUrl),t("div.release_info .date").text(s.date),t("div.release_info #targetMCU").text(s.mcu),t("div.release_info .configFilename").text(e.isConfigLocal?e.configFilename:"[default]"),s.cloudBuild?(t("div.release_info #cloudTargetInfo").show(),t("div.release_info #cloudTargetLog").text(""),t("div.release_info #cloudTargetStatus").text("pending")):t("div.release_info #cloudTargetInfo").hide(),e.targets&&(t("div.release_info").slideDown(),t(".tab-firmware_flasher .content_wrapper").animate({scrollTop:t("div.release_info").position().top},1e3))}function f(){e.config={},e.isConfigLocal=!1,e.configFilename=null}function c(s,i){e.config=s.join(`
`),e.isConfigLocal=i!==void 0,e.configFilename=i!==void 0?i:null}function _(s,i){e.intel_hex=s,a(e.intel_hex,function(h){e.parsed_hex=h,e.parsed_hex?n(i):(e.flashingMessage(l.getMessage("firmwareFlasherHexCorrupted"),e.FLASH_MESSAGE_TYPES.INVALID),e.enableFlashButton(!1))})}function x(s,i){e.localFirmwareLoaded=!1,_(s,i),e.enableLoadRemoteFileButton(!0),t("a.load_remote_file").text(l.getMessage("firmwareFlasherButtonLoadOnline"))}function F(s){if(!s||!le()){t('select[name="board"]').empty().append('<option value="0">Offline</option>'),t('select[name="firmware_version"]').empty().append('<option value="0">Offline</option>');return}const i=t('select[name="board"]');i.empty(),i.append(t(`<option value='0'>${l.getMessage("firmwareFlasherOptionLabelSelectBoard")}</option>`));const h=t('select[name="firmware_version"]');h.empty(),h.append(t(`<option value='0'>${l.getMessage("firmwareFlasherOptionLabelSelectFirmwareVersion")}</option>`)),Object.keys(s).sort((p,v)=>p.target-v.target).forEach(function(p,v){const S=s[p],R=t(`<option value='${S.target}'>${S.target}</option>`);i.append(R)}),g.firmware_flasher.targets=s,t("div.build_configuration").slideUp()}function k(s,i){s.empty(),i.forEach(h=>{h.default?s.append(t(`<option value='${h.value}' selected>${h.name}</option>`)):s.append(t(`<option value='${h.value}'>${h.name}</option>`))})}function I(){const s=t('select[name="radioProtocols"] option:selected').val(),i=["USE_SERIALRX_CRSF","USE_SERIALRX_FPORT","USE_SERIALRX_GHST","USE_SERIALRX_JETIEXBUS"].includes(s);t('select[name="telemetryProtocols"]').attr("disabled",i),i?t('select[name="telemetryProtocols"] option[value="-1"]').length===0?t('select[name="telemetryProtocols"]').prepend(t("<option>",{value:"-1",selected:"selected",text:l.getMessage("firmwareFlasherOptionLabelTelemetryProtocolIncluded")})):t('select[name="telemetryProtocols"] option:first').attr("selected","selected").text(l.getMessage("firmwareFlasherOptionLabelTelemetryProtocolIncluded")):t('select[name="telemetryProtocols"] option[value="-1"]').length&&t('select[name="telemetryProtocols"] option:first').remove()}function L(){const s=t('select[name="osdProtocols"] option:selected').val();t('select[name="osdProtocols"]').next(".select2-container").find(".select2-selection__rendered").attr("style",s===""?"color: red !important":"")}function P(s){le()&&(console.log(`${e.logHead} buildOptions`,E.CONFIG.buildOptions),e.cloudBuildOptions=E.CONFIG.buildOptions||[],s.osdProtocols=s.generalOptions.filter(i=>i.group==="OSD").map(i=>{var h;return i.name=i.groupedName,i.default=(h=e.cloudBuildOptions)==null?void 0:h.includes(i.value),i}),s.osdProtocols.unshift({name:"None",value:""}),s.generalOptions=s.generalOptions.filter(i=>!i.group),k(t('select[name="radioProtocols"]'),s.radioProtocols),k(t('select[name="telemetryProtocols"]'),s.telemetryProtocols),k(t('select[name="osdProtocols"]'),s.osdProtocols),k(t('select[name="options"]'),s.generalOptions),k(t('select[name="motorProtocols"]'),s.motorProtocols),setTimeout(L,0),t('select[name="osdProtocols"]').on("change",L),e.validateBuildKey()||D(),I())}function D(){const s=H("ffRadioProtocol").ffRadioProtocol;s&&t('select[name="radioProtocols"] option').filter(function(h,p){return p.value===s}).length!==0&&t('select[name="radioProtocols"]').val(s)}let V;const G=t('select[name="build_type"]');function ye(){G.empty(),V.forEach(({tag:s,title:i},h)=>{G.append(t(`<option value='${h}'>${s?l.getMessage(s):i}</option>`))})}const re=[{tag:"firmwareFlasherOptionLabelBuildTypeRelease"},{tag:"firmwareFlasherOptionLabelBuildTypeReleaseCandidate"},{tag:"firmwareFlasherOptionLabelBuildTypeDevelopment"}];function Le(){t(this).is(":checked")?t("tr.build_type").show():(t("tr.build_type").hide(),G.val(0).trigger("change"))}function Me(){const s=t(this).is(":checked");s?V=re:V=re.slice(0,2),ye(),G.val(0).trigger("change"),setTimeout(()=>{t("tr.expertOptions").toggle(s),t("div.expertOptions").toggle(s)},0),U({expertMode:s})}const K=t(".tab-firmware_flasher input.expert_mode"),ke=H("expertMode").expertMode;K.prop("checked",ke),K.on("change",Me).trigger("change"),t("input.show_development_releases").change(Le).change(),l.localizePage(),e.sponsor.loadSponsorTile("flash",t("div.tab_sponsor")),G.on("change",function(){e.enableLoadRemoteFileButton(!1);const s=G.val();if(t('select[name="board"]').empty().append(t(`<option value='0'>${l.getMessage("firmwareFlasherOptionLoading")}</option>`)),t('select[name="firmware_version"]').empty().append(t(`<option value='0'>${l.getMessage("firmwareFlasherOptionLoading")}</option>`)),!m.connect_lock)try{e.buildApi.loadTargets(F)}catch(i){console.error(i)}U({selected_build_type:s})});function ce(s){t("div.build_configuration").slideUp(),t("div.release_info").slideUp(),e.localFirmwareLoaded||(e.enableFlashButton(!1),e.flashingMessage(l.getMessage("firmwareFlasherLoadFirmwareFile"),e.FLASH_MESSAGE_TYPES.NEUTRAL),e.parsed_hex&&e.parsed_hex.bytes_total&&(console.log(`${e.logHead} throw out loaded hex`),e.intel_hex=void 0,e.parsed_hex=void 0));const i=t('select[name="board"] option:selected').val();function h(v){if(e.targetDetail=v,v.cloudBuild===!0){t("div.build_configuration").slideDown();const S=K.is(":checked");S&&(v.releaseType==="Unstable"?(e.buildApi.loadCommits(v.release,R=>{const C=t('select[name="commits"]');C.empty(),R.forEach(b=>{C.append(t(`<option value='${b.sha}'>${b.message.split(`
`)[0]}</option>`))})}),t("div.commitSelection").show()):t("div.commitSelection").hide()),t("div.expertOptions").toggle(S),t("input.corebuild_mode").trigger("change")}v.configuration&&!e.isConfigLocal&&c(v.configuration),e.enableLoadRemoteFileButton(!0)}e.buildApi.loadTarget(i,s,h);const p=()=>e.buildApi.loadOptions(s,P);e.validateBuildKey()?e.buildApi.loadOptionsByBuildKey(s,e.cloudBuildKey,P,p):p()}function Te(s,i){const h=function(v,S){return-Z.compareBuild(v.release,S.release)};s.empty();const p=i.releases;if(p.length>0){s.append(t(`<option value='0'>${l.getMessage("firmwareFlasherOptionLabelSelectFirmwareVersionFor")} ${i.target}</option>`));const v=t('select[name="build_type"]').val();p.sort(h).filter(S=>S.type==="Unstable"&&v>1||S.type==="ReleaseCandidate"&&v>0||S.type==="Stable").forEach(function(S){const R=S.release,C=t(`<option value='${R}'>${R} [${S.label}]</option>`),b=`${i}/${S}`;C.data("summary",b),s.append(C)}),s.prop("selectedIndex",1),ce(s.val())}}function de(){f(),e.intel_hex=void 0,e.parsed_hex=void 0,e.localFirmwareLoaded=!1}t('select[name="board"]').select2(),t('select[name="osdProtocols"]').select2(),t('select[name="radioProtocols"]').select2(),t('select[name="telemetryProtocols"]').select2(),t('select[name="motorProtocols"]').select2(),t('select[name="options"]').select2({tags:!1,closeOnSelect:!1}),t('select[name="commits"]').select2({tags:!0}),t('select[name="options"]').on("select2:opening",function(){t(this).parent().find(".select2-search__field").prop("disabled",!1)}).on("select2:closing",function(){t(this).parent().find(".select2-search__field").prop("disabled",!0)}),t('select[name="radioProtocols"]').on("select2:select",function(){const s=t('select[name="radioProtocols"] option:selected').first().val();s&&U({ffRadioProtocol:s}),I()}),t('select[name="board"]').on("change",function(){e.enableLoadRemoteFileButton(!1);let s=t(this).val();if(s===null&&(s="0",t(this).val(s).trigger("change")),!m.connect_lock){e.selectedBoard=s,console.log(`${e.logHead} board changed to`,s),e.flashingMessage(l.getMessage("firmwareFlasherLoadFirmwareFile"),e.FLASH_MESSAGE_TYPES.NEUTRAL).flashProgress(0),t("div.release_info").slideUp(),t("div.build_configuration").slideUp(),e.localFirmwareLoaded||e.enableFlashButton(!1);const i=t('select[name="firmware_version"]');s==="0"?(de(),i.empty(),i.append(t(`<option value='0'>${l.getMessage("firmwareFlasherOptionLabelSelectFirmwareVersion")}</option>`))):(i.empty(),i.append(t(`<option value='0'>${l.getMessage("firmwareFlasherOptionLoading")}</option>`)),e.buildApi.loadTargetReleases(s,h=>Te(i,h)))}});const Be=['select[name="board"]','select[name="radioProtocols"]','select[name="telemetryProtocols"]','select[name="osdProtocols"]','select[name="motorProtocols"]','select[name="options"]','select[name="commits"]'];t(document).on("select2:open",Be.join(","),()=>{const s=document.querySelectorAll(".select2-container--open .select2-search__field");t(this).one("mouseup keyup",()=>{setTimeout(()=>{s[s.length-1].focus()},0)})});function He(s){let i=[],h=!1;for(let p=0;p<s.length;p++){if((s.charAt(p)===`
`||s.charAt(p)==="\r")&&(h=!1),s.charAt(p)==="#"&&(h=!0),!h&&s.charCodeAt(p)>255)return e.flashingMessage(l.getMessage("firmwareFlasherConfigCorrupted"),e.FLASH_MESSAGE_TYPES.INVALID),y(l.getMessage("firmwareFlasherConfigCorruptedLogMessage")),null;s.charCodeAt(p)>255?i.push("_"):i.push(s.charAt(p))}return i.join("").split(`
`)}function Ie(s){const i=t("input.flash_on_connect").is(":checked");console.log(`${e.logHead} Detected USB device:`,s),console.log(`${e.logHead} Reboot mode: %s, flash on connect`,te.rebootMode,i),(te.rebootMode||i)&&(te.rebootMode=0,m.connect_lock=!1,q())}Ve.$on("port-handler:auto-select-usb-device",Ie);function Pe(s){const i={};(t("input.erase_chip").is(":checked")||K.is(":not(:checked)"))&&(i.erase_chip=!0);const h=N.portPicker.selectedPort,p=h.startsWith("serial_"),v=h.startsWith("usb_");if(console.log(`${e.logHead} Selected port:`,h),v)O.sendEvent(O.EVENT_CATEGORIES.FLASHING,"DFU Flashing",{filename:e.filename||null}),z.connect(h,s,i);else if(p){t("input.updating").is(":checked")?i.no_reboot=!0:i.reboot_baud=N.portPicker.selectedBauds;let S=115200;t("input.flash_manual_baud").is(":checked")&&(S=parseInt(t("#flash_manual_baud_rate").val())||115200),O.sendEvent(O.EVENT_CATEGORIES.FLASHING,"Flashing",{filename:e.filename||null}),te.connect(h,S,s,i)}else console.log(`${e.logHead} No valid port detected, asking for permissions`),z.requestPermission().then(S=>{z.connect(S.path,s,i)});e.isFlashing=!1,m.interval_resume("sponsor")}let T=H("erase_chip");t("input.erase_chip").prop("checked",T.erase_chip),t("input.erase_chip").change(function(){U({erase_chip:t(this).is(":checked")})}).change(),T=H("show_development_releases"),t("input.show_development_releases").prop("checked",T.show_development_releases).change(function(){U({show_development_releases:t(this).is(":checked")})}).change(),T=H("selected_build_type"),G.val(T.selected_build_type||0).trigger("change"),T=H("no_reboot_sequence"),T.no_reboot_sequence?(t("input.updating").prop("checked",!0),t(".flash_on_connect_wrapper").show()):t("input.updating").prop("checked",!1),t("input.updating").change(function(){const s=t(this).is(":checked");s?t(".flash_on_connect_wrapper").show():(t("input.flash_on_connect").prop("checked",!1).change(),t(".flash_on_connect_wrapper").hide()),U({no_reboot_sequence:s})}),t("input.updating").change(),T=H("flash_manual_baud"),T.flash_manual_baud?t("input.flash_manual_baud").prop("checked",!0):t("input.flash_manual_baud").prop("checked",!1),t("input.corebuild_mode").change(function(){const s=t(this).is(":checked");t(".hide-in-core-build-mode").toggle(!s),t("div.expertOptions").toggle(!s&&K.is(":checked"))}),t("input.corebuild_mode").change(),t("input.flash_manual_baud").change(function(){const s=t(this).is(":checked");U({flash_manual_baud:s})}),t("input.flash_manual_baud").change(),T=H("flash_manual_baud_rate"),t("#flash_manual_baud_rate").val(T.flash_manual_baud_rate),t("#flash_manual_baud_rate").change(function(){const s=parseInt(t("#flash_manual_baud_rate").val());U({flash_manual_baud_rate:s})}),t("input.flash_manual_baud_rate").change(),t("a.load_file").on("click",function(){e.enableFlashButton(!1),e.enableLoadRemoteFileButton(!1),e.developmentFirmwareLoaded=!1,Y.pickOpenFile(l.getMessage("fileSystemPickerFiles",{typeof:"HEX"}),".hex").then(s=>{console.log(`${e.logHead} Saving firmware to:`,s.name),Y.readFile(s).then(i=>{if(s.name.split(".").pop()==="hex")e.intel_hex=i,a(e.intel_hex,function(h){e.parsed_hex=h,e.parsed_hex?(e.localFirmwareLoaded=!0,n(s.name)):e.flashingMessage(l.getMessage("firmwareFlasherHexCorrupted"),e.FLASH_MESSAGE_TYPES.INVALID)});else{de();let h=He(i);h!==null&&(c(h,s.name),e.isConfigLocal&&!e.parsed_hex&&e.flashingMessage(l.getMessage("firmwareFlasherLoadedConfig"),e.FLASH_MESSAGE_TYPES.NEUTRAL),(e.isConfigLocal&&e.parsed_hex&&!e.localFirmwareLoaded||e.localFirmwareLoaded)&&(e.enableFlashButton(!0),e.flashingMessage(l.getMessage("firmwareFlasherFirmwareLocalLoaded",e.parsed_hex.bytes_total),e.FLASH_MESSAGE_TYPES.NEUTRAL)))}})}).catch(s=>{console.error("Error reading file:",s),e.enableLoadRemoteFileButton(!0)})}),t('select[name="firmware_version"]').change(s=>{ce(t("option:selected",s.target).val())}),t("a.cloud_build_cancel").on("click",function(s){t("a.cloud_build_cancel").toggleClass("disabled",!0),e.cancelBuild=!0});async function Oe(){return t('select[name="firmware_version"] option:selected').text().startsWith("4.3.")?!0:t('select[name="osdProtocols"] option:selected').val()===""?new Promise(i=>{m.showYesNoDialog({title:l.getMessage("firmwareFlasherOSDProtocolNotSelected"),text:l.getMessage("firmwareFlasherOSDProtocolNotSelectedDescription"),buttonYesText:l.getMessage("firmwareFlasherOSDProtocolNotSelectedContinue"),buttonNoText:l.getMessage("firmwareFlasherOSDProtocolSelect"),buttonYesCallback:()=>i(!0),buttonNoCallback:()=>i(!1)})}):!0}t("a.load_remote_file").on("click",async function(s){if(!e.selectedBoard||!await Oe())return;if(e.enableFlashButton(!1),e.enableLoadRemoteFileButton(!1),e.localFirmwareLoaded=!1,e.developmentFirmwareLoaded=V[t('select[name="build_type"]').val()].tag==="firmwareFlasherOptionLabelBuildTypeDevelopment",t('select[name="firmware_version"]').val()==="0"){y(l.getMessage("firmwareFlasherNoFirmwareSelected"));return}function h(){t("span.progressLabel").attr("i18n","firmwareFlasherFailedToLoadOnlineFirmware").removeClass("i18n-replaced"),e.enableLoadRemoteFileButton(!0),t("a.load_remote_file").text(l.getMessage("firmwareFlasherButtonLoadOnline")),l.localizePage()}function p(C,b,Q,A){A===!0&&t("div.release_info #cloudTargetLog").text(l.getMessage("firmwareFlasherCloudBuildLogUrl")).prop("href",`https://build.Ovobot.com/api/builds/${b}/log`),t("div.release_info #cloudTargetStatus").text(l.getMessage(`firmwareFlasherCloudBuild${C}`)),t(".buildProgress").val(Q)}function v(C,b,Q){b.status==="success"&&(p(`Success${Q}`,C.key,100,!0),b.configuration!==void 0&&!e.isConfigLocal&&c(b.configuration),e.buildApi.loadTargetHex(C.url,A=>x(A,C.file),h))}function S(C,b){p(`Fail${b}`,C,0,!0),h()}function R(C){let b={target:C.target,release:C.release,options:[]};(C.cloudBuild!==!0||t('input[name="coreBuildModeCheckbox"]').is(":checked"))===!0?b.options.push("CORE_BUILD"):(b.options.push("CLOUD_BUILD"),t('select[name="radioProtocols"] option:selected').each(function(){b.options.push(t(this).val())}),t('select[name="telemetryProtocols"] option:selected').each(function(){b.options.push(t(this).val())}),t('select[name="options"] option:selected').each(function(){b.options.push(t(this).val())}),t('select[name="osdProtocols"] option:selected').each(function(){b.options.push(t(this).val())}),t('select[name="motorProtocols"] option:selected').each(function(){b.options.push(t(this).val())}),t('input[name="expertModeCheckbox"]').is(":checked")&&(C.releaseType==="Unstable"&&(b.commit=t('select[name="commits"] option:selected').val()),t('input[name="customDefines"]').val().split(" ").map(A=>A.trim()).forEach(A=>{b.options.push(A)}))),console.info("Build request:",b),e.buildApi.requestBuild(b,A=>{if(console.info("Build response:",A),e.targetDetail.file=A.file,!C.cloudBuild){e.buildApi.loadTargetHex(A.url,ee=>x(ee,A.file),h);return}p("Pending",A.key,0,!1),e.cancelBuild=!1,e.buildApi.requestBuildStatus(A.key,ee=>{if(ee.status==="success"){v(A,ee,"Cached");return}e.enableCancelBuildButton(!0);const fe=5;let W=1,oe=!1,ge=120;const Ne=setInterval(()=>{e.buildApi.requestBuildStatus(A.key,X=>{X.timeOut!==void 0&&(oe||(oe=!0,W=1),ge=X.timeOut);const ae=ge/fe;if(X.status!=="queued"||W>ae||e.cancelBuild){if(e.enableCancelBuildButton(!1),clearInterval(Ne),X.status==="success"){v(A,X,"");return}let ie="";W>ae&&(ie="TimeOut"),e.cancelBuild&&(ie="Cancel"),S(A.key,ie);return}oe&&p("Processing",A.key,W*(100/ae),!1),W++})},fe*1e3)})},()=>{p("FailRequest","",0,!1),h()})}e.targetDetail?(t("a.load_remote_file").text(l.getMessage("firmwareFlasherButtonDownloading")),e.enableLoadRemoteFileButton(!1),d(e.targetDetail),R(e.targetDetail)):(t("span.progressLabel").attr("i18n","firmwareFlasherFailedToLoadOnlineFirmware").removeClass("i18n-replaced"),l.localizePage())}),t("a.exit_dfu").on("click",function(){if(e.enableDfuExitButton(!1),!m.connect_lock){O.sendEvent(O.EVENT_CATEGORIES.FLASHING,"ExitDfu",null);try{console.log(`${e.logHead} Closing DFU`),z.requestPermission().then(s=>{z.connect(s.path,e.parsed_hex,{exitDfu:!0})})}catch(s){console.log(`${e.logHead} Exiting DFU failed: ${s.message}`)}}});const he=t("#targetSupportInfoUrl");he.on("click",function(){let s="https://Ovobot.com/docs/wiki/boards/archive/Missing";const i=`https://Ovobot.com/docs/wiki/boards/current/${e.selectedBoard}`;qe(i)&&(s=i),he.attr("href",s)});const se=t("a.detect-board");se.on("click",()=>{se.toggleClass("disabled",!0),m.connect_lock||rt.verifyBoard(N.portPicker.selectedPort),setTimeout(()=>se.toggleClass("disabled",!1),2e3)});function J(){e.developmentFirmwareLoaded?$e():q()}function ue(s){m.connect_lock=!0;const i=function(p){m.connect_lock=!1,e.isFlashing=!1,e.enableFlashButton(!0),e.enableLoadRemoteFileButton(!0),e.enableLoadFileButton(!0),m.interval_resume("sponsor"),e.flashingMessage(l.getMessage(p),e.FLASH_MESSAGE_TYPES.INVALID)},h=function(){const p=Date.now(),v=setInterval(()=>{N.portAvailable?(clearInterval(v),s()):Date.now()-p>5e3&&(clearInterval(v),i("portsSelectNone"))},100)};nt.execute(p=>{m.connect_lock=!1,p?h():i("firmwareFlasherCanceledBackup")})}function $e(){const i="lastDevelopmentWarningTimestamp";function h(){const p={};p[i]=Date.now(),Ke(p)}T=Ye(i),!T[i]||Date.now()-T[i]>864e5?De(h):q()}function De(s){const i=t("#dialogUnstableFirmwareAcknowledgement")[0],h=t("#dialogUnstableFirmwareAcknowledgement-flashbtn"),p=t('input[name="dialogUnstableFirmwareAcknowledgement-acknowledge"]');p.change(function(){t(this).is(":checked")?h.removeClass("disabled"):h.addClass("disabled")}),h.click(function(){i.close(),p.is(":checked")&&(s&&s(),q())}),t("#dialogUnstableFirmwareAcknowledgement-cancelbtn").click(function(){i.close()}),i.addEventListener("close",function(){p.prop("checked",!1).change()}),i.showModal()}function q(){if(!m.connect_lock)if(e.parsed_hex){try{e.config&&!e.parsed_hex.configInserted&&(new Qe().insertConfig(e.parsed_hex,e.config)?e.parsed_hex.configInserted=!0:(console.log(`${e.logHead} Firmware does not support custom defaults.`),f())),Pe(e.parsed_hex)}catch(s){console.log(`${e.logHead} Flashing failed: ${s.message}`)}t("input.flash_on_connect").prop("checked",!1).change()}else t("span.progressLabel").attr("i18n","firmwareFlasherFirmwareNotLoaded").removeClass("i18n-replaced"),l.localizePage()}t("a.flash_firmware").on("click",function(){if(m.connect_lock)return;if(e.isFlashing=!0,m.interval_pause("sponsor"),e.enableFlashButton(!1),e.enableDfuExitButton(!1),e.enableLoadRemoteFileButton(!1),e.enableLoadFileButton(!1),t("input.flash_on_connect").is(":checked")||!N.portAvailable){q();return}switch(H("backupOnFlash",1).backupOnFlash){case 1:ue(J);break;case 2:m.showYesNoDialog({title:l.getMessage("firmwareFlasherRemindBackupTitle"),text:l.getMessage("firmwareFlasherRemindBackup"),buttonYesText:l.getMessage("firmwareFlasherBackup"),buttonNoText:l.getMessage("firmwareFlasherBackupIgnore"),buttonYesCallback:()=>{ue(J)},buttonNoCallback:J});break;default:J();break}}),t("span.progressLabel").on("click","a.save_firmware",function(){Y.pickSaveFile(e.targetDetail.file,l.getMessage("fileSystemPickerFiles",{typeof:"HEX"}),".hex").then(s=>{console.log(`${e.logHead} Saving firmware to:`,s.name),Y.writeFile(s,e.intel_hex),O.sendEvent(O.EVENT_CATEGORIES.FLASHING,"SaveFirmware")}).catch(s=>{console.error("Error saving file:",s)})}),e.flashingMessage(l.getMessage("firmwareFlasherLoadFirmwareFile"),e.FLASH_MESSAGE_TYPES.NEUTRAL),N.dfuAvailable&&t("a.exit_dfu").removeClass("disabled"),m.content_ready(r)}e.buildApi.loadTargets(()=>{console.log(`${e.logHead} Targets loaded`),t("#content").load("./tabs/firmware_flasher.html",o)})};M.validateBuildKey=function(){var r;return((r=this.cloudBuildKey)==null?void 0:r.length)===32&&le()};M.cleanup=function(r){t(document).unbind("keypress"),t(document).off("click","span.progressLabel a"),r&&r()};M.enableCancelBuildButton=function(r){t("a.cloud_build_cancel").toggleClass("disabled",!r),self.cancelBuild=!1};M.enableFlashButton=function(r){t("a.flash_firmware").toggleClass("disabled",!r)};M.enableLoadRemoteFileButton=function(r){t("a.load_remote_file").toggleClass("disabled",!r)};M.enableLoadFileButton=function(r){t("a.load_file").toggleClass("disabled",!r)};M.enableDfuExitButton=function(r){t("a.exit_dfu").toggleClass("disabled",!r)};M.refresh=function(r){const e=this;m.tab_switch_cleanup(function(){e.initialize(),r&&r()})};M.showDialogVerifyBoard=function(r,e,o,a){const n=t("#dialog-verify-board")[0];t("#dialog-verify-board-content").html(l.getMessage("firmwareFlasherVerifyBoard",{selected_board:r,verified_board:e})),n.hasAttribute("open")||(n.showModal(),t("#dialog-verify-board-continue-confirmbtn").on("click",function(){n.close(),o()}),t("#dialog-verify-board-abort-confirmbtn").on("click",function(){n.close(),a()}))};M.FLASH_MESSAGE_TYPES={NEUTRAL:"NEUTRAL",VALID:"VALID",INVALID:"INVALID",ACTION:"ACTION"};M.flashingMessage=function(r,e){let o=this,a=t("span.progressLabel");switch(e){case o.FLASH_MESSAGE_TYPES.VALID:a.removeClass("invalid actionRequired").addClass("valid");break;case o.FLASH_MESSAGE_TYPES.INVALID:a.removeClass("valid actionRequired").addClass("invalid");break;case o.FLASH_MESSAGE_TYPES.ACTION:a.removeClass("valid invalid").addClass("actionRequired");break;case o.FLASH_MESSAGE_TYPES.NEUTRAL:default:a.removeClass("valid invalid actionRequired");break}return r!==null&&a.html(r),o};M.flashProgress=function(r){return t(".progress").val(r),this};M.injectTargetInfo=function(r,e,o,a){const n=/^# config: manufacturer_id: .*, board_name: .*, version: .*$, date: .*\n/gm,d=r.replace(n,""),f=`# config: manufacturer_id: ${o}, board_name: ${e}, version: ${a.commitHash}, date: ${a.date}`,c=d.split(`
`);return c.splice(1,0,f),c.join(`
`)};g.firmware_flasher=M;export{M as firmware_flasher};
